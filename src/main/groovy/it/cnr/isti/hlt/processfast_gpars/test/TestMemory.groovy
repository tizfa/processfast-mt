/*
 * *****************
 *  Copyright 2015 Tiziano Fagni (tiziano.fagni@isti.cnr.it)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * *******************
 */

package it.cnr.isti.hlt.processfast_gpars.test

import it.cnr.isti.hlt.processfast.core.TaskDescriptor
import it.cnr.isti.hlt.processfast.data.CollectionDataSourceIteratorProvider
import it.cnr.isti.hlt.processfast.data.PairPartitionableDataset
import it.cnr.isti.hlt.processfast_gpars.core.GParsRuntime

import java.util.regex.Pattern

GParsRuntime runtime = new GParsRuntime()
runtime.numThreadsForDataParallelism = 10
def ts = runtime.createTaskSet()

ts.task { TaskDescriptor tc ->
    def pattern = Pattern.compile("([\\s]+)|([\\:\\.\\,\\;\"\\<\\>\\[\\]\\{\\}\\\\/'\\\\&\\#\\*\\(\\)\\=\\?\\^\\!\\|])")
    String text = "Assembly. Il linguaggio assembly, detto anche linguaggio assemblativo, è, tra i linguaggi di programmazione, quello più vicino al linguaggio macchina vero e proprio, pur essendo differente rispetto a quest'ultimo. Erroneamente viene spesso chiamato \"assembler\", anche se quest'ultimo termine identifica il programma \"assemblatore\" che converte il linguaggio assembly in linguaggio macchina.Caratteristiche generali dell'assembly.L'assembly ha lo scopo generale di consentire al programmatore di ignorare il formato binario del linguaggio macchina.Ogni codice operativo del linguaggio macchina viene sostituito, nell'assembly, da una sequenza di caratteri che lo rappresenta in forma \"mnemonica\"; per esempio, il codice operativo per la somma potrebbe essere trascritto come codice_1 e quello per il salto come codice_2.In secondo luogo, i dati e gli indirizzi di memoria manipolati dal programma possono essere scritti, in assembly, nella base numerica più consona al momento: esadecimale, binaria, decimale, ottale ma anche in forma simbolica, utilizzando stringhe di testo (identificatori).Il programma assembly risulta in questo modo relativamente più leggibile di quello in linguaggio macchina, con il quale mantiene però un totale (o quasi totale) isomorfismo.Il programma scritto in assembly non può essere eseguito direttamente dal processore; esso deve essere tradotto nella forma binaria corrispondente, usando un programma compilatore detto assembler.Non c'è un solo assembly.A causa di questa \"vicinanza\" all'hardware, non esiste un unico linguaggio assembly.Al contrario, ogni CPU o famiglia di CPU ha un suo proprio assembly, diverso dagli altri.Ad esempio, sono linguaggi assembly ben diversi quelli per i processori Intel x86, per i Motorola 68000 e per i Dec Alpha.Questo significa che conoscere un certo linguaggio assembly significa saper scrivere programmi solo su una determinata CPU o famiglia di CPU.Passare ad altre CPU però è relativamente facile, perché molti meccanismi sono analoghi o del tutto identici, quindi spesso il passaggio si limita all'apprendimento di nuovi codici mnemonici, nuove modalità di indirizzamento ed altre varie peculiarità del nuovo processore.Molto meno facile è invece portare un programma scritto in assembly su macchine con processori diversi o con architetture diverse: quasi sempre significa dover riscrivere il programma da cima a fondo, perché i linguaggi assembly dipendono completamente dalla piattaforma per cui sono stati scritti.Molti compilatori assembly supportano sistemi di macro che potrebbero essere impiegati per ovviare in parte a questo problema, ma si tratta di una soluzione poco efficace.Inoltre l'assembly non offre alcun \"controllo sui tipi\" (non esiste alcunché di vagamente simile al concetto di \"tipo\" nella programmazione \"low-level\"), ma lascia al programmatore la responsabilità di occuparsi di ogni singolo dettaglio della gestione della macchina e richiede molta disciplina e un esteso lavoro di commento per non scrivere codice che risulti assolutamente illeggibile (ad altri programmatori come anche a se stessi dopo qualche tempo).A fronte di questi svantaggi l'assembly offre un'efficienza senza pari e il controllo completo e assoluto sull'hardware: i programmi in assembly sono, in linea di principio, i più piccoli e veloci che sia possibile scrivere su una data macchina.Scrivere (buon) codice in assembly è dispendioso in termini di tempo, difficile e quindi molto costoso, soprattutto in prospettiva (future modifiche): per questo, raramente l'assembly è il solo linguaggio usato in un progetto mainstream, a meno che questo non sia di dimensioni e portata limitate.In genere si usa in combinazione con altri linguaggi: la maggior parte del codice viene scritta in un linguaggio ad alto livello, mentre le parti più critiche (per motivi di performance, precisione del timing o affidabilità) si scrivono in assembly.Tali problematiche sono riscontrabili principalmente su piattaforme come i \"personal computer\" attuali, dove la vastità quantitativa e l'enorme gamma qualitativa dell'hardware disponibile crea alle applicazioni low-level un oggettivo problema mai risolto (e presumibilmente non risolvibile) a livello di unificazione e standard.A ciò si aggiunga l'evoluzione costante verso una sempre maggiore stratificazione dei comuni sistemi operativi, caratterizzata da numerosi vincoli e virtualizzazioni delle periferiche fisiche e dei canali di comunicazione, che non rendono agevole lo sviluppo di un software che interagisca direttamente con l'hardware sottostante e ne gestisca direttamente le caratteristiche.Si possono però citare due esempi, peraltro correlati, di totale inversione di questo paradigma generale:Ecco allora che la possibilità di utilizzare un microcontroller con limitatissime risorse di memoria ROM e RAM scrivendo il firmware integralmente in assembly diventa essenziale al fine di minimizzare i costi, l'ingombro in piastra, la suscettibilità elettromagnetica, aumentando anche l'affidabilità (processori più \"datati\" hanno un incolmabile vantaggio in termini di milioni di ore di test e funzionamento sul campo, ossia la \"merce\" di gran lunga più preziosa per i sistemi embedded variamente critici) ed ottimizzando numerosi altri fattori.RISC e CISC.Il linguaggio assembly costituisce il cosiddetto ISA (Instruction Set Architecture) di un processore.I diversi ISA possono essere divisi in due grandi gruppi: i RISC (Reduced Instruction Set Computer) e i CISC (Complex Instruction Set Computer).Il primo gruppo tende ad avere operazioni semplici e veloci, con grande abbondanza di registri per memorizzare i risultati intermedi.Il secondo mette a disposizione del programmatore istruzioni più complesse, che a volte mimano quelle dei linguaggi di livello più alto (ad esempio, la copia di stringhe nei processori x86).In entrambi i casi, i migliori set di istruzioni tendono ad essere quelli cosiddetti \"ortogonali\", dove i diversi metodi di indirizzamento e i diversi registri possono essere usati indifferentemente in tutte le istruzioni.Famosi set di istruzioni ortogonali sono quelli del Motorola 68000 (CISC) e del MIPS (RISC).L'ISA dei processori Intel x86 era originariamente ben poco ortogonale, ed è andata via via migliorando.La distinzione tra \"set\" di istruzioni RISC e CISC è oggi un po' sfumata, perché la maggior parte dei processori consumer sono oggi dei CRISP, cioè un misto fra i due.Inoltre, alcuni processori traducono l'ISA originale in un set di istruzioni interno, per ragioni diverse e con modalità diverse:Struttura.La struttura di un tipico listato Assembly x86 per PC si articola, a grandi linee, nei seguenti termini:Vale la pena di ribadire che tale struttura, nella sua generalità, dipende quasi per intero dalla piattaforma e anche dall'assembler utilizzato e quindi non è in alcun modo universalizzabile. Architetture diverse, dai mainframe ai microcontroller, con relativi assemblatori e cross-assembler, impongono strutture di sorgente a volte nettamente diverse dal semplice esempio illustrato, relativo ai comuni PC. Per un controesempio banale, nelle architetture Harvard usate dalla quasi totalità dei microcontroller e da molte architetture di supercalcolo: Esempio di codice.Esempio di programma \"Hello world\" in assembly Intel x86 con sintassi Intel (sfrutta le chiamate al sistema operativo DOS). Non è compatibile con le versioni Assembly UNIX GNUQuesto invece è l'esempio del programma scritto per sintassi AT&T (per le architetture UNIX GNU)Microistruzioni.Quando si esegue un'istruzione Assembly, il processore (in base all'architettura presa in considerazione) esegue una serie di operazioni chiamate \"Microistruzioni Assembly\", cioè delle operazioni hardware che servono per configurare i registri e gli operatori della CPU in modo che possa essere eseguita quella istruzione.Tale processo si divide, nel caso delle CPU Intel x86 e di alcune altre, in 3 parti:Da qui la sigla FDE, Fetch-Decode-Execute, riportata nei testi di architettura e nei datasheet.Per fare un esempio per l'architettura dell'Intel 80x86 con un singolo BUS, in sintassi AT&T, questa istruzione:in cui si somma il contenuto del registro EAX con il contenuto del registro EBX e il risultato verrà salvato in EAX, vengono svolte queste microoperazioni:Su alcune architetture tali fasi risultano invece essere quattro (ad esempio, nei PIC Microchip, negli Intel 8051 e in numerosissimi core analoghi), da cui risulta anche l'effettivo rapporto tra velocità di clock ossia frequenza del quarzo esterno (es. 10 MHz) e numero di istruzioni effettivamente eseguite in un secondo. Per i PIC tale rapporto è pari ad 1/4, poiché ad ogni ciclo di clock il core esegue effettivamente una singola fase Fetch-Decode-Execute-Write e dunque sono necessari quattro cicli del clock esterno per completare una singola istruzione. Su architetture di microcontroller e core più arcaiche o comunque di diversa concezione, sono necessari anche più cicli di clock per ciascuna fase (ad esempio tre o quattro), da cui il diverso rapporto tra clock e MIPS, che nel caso del design 8051 originale richiede ad esempio 12 cicli di clock per ciascuna singola istruzione.Si ricordi infine che talune istruzioni, tra le quali tipicamente i salti incondizionati, richiedono su un numero notevole di piattaforme (sia RISC che CISC, concepite in varie epoche) un numero di cicli superiore alle altre, a causa delle operazioni accessorie (non parallelizzabili) richieste dall'aggiornamento del registro IP e di eventuali code di prefetch interne.C-asm.Talvolta, nella programmazione ad alto livello in ambienti come il DOS, c'è la necessità di effettuare alcune operazioni che sono molto più veloci usando delle istruzioni di linguaggi a basso livello (in Windows invece a causa delle protezioni della memoria si ricorre più frequentemente alle chiamate WINAPI, le chiamate in L/M sono usate per lo più per procedure matematiche accelerate o dai driver). Tra i linguaggi ad alto livello che permettono questo vi sono il C e il C++, in cui possono essere inserite nei propri sorgenti parti scritte in assembly e, che in fase di compilazione, verranno tradotte con un procedimento noto come assembler inline.Un esempio di codice scritto in C-asm (usando l'assembly Intel x86), che visualizza in binario un numero dato in input, è il seguente:Dato che oramai la potenza dei PC è elevatissima e che i compilatori hanno una grande quantità di ottimizzazioni, i programmatori \"normali\" hanno sempre meno la necessità di interfacciarsi a basso livello, a favore della portabilità e leggibilità del codice.Strutture di controllo in Assembly x86.Il processore esegue le istruzioni così come si presentano, una dopo l'altra. Tuttavia, attraverso particolari strutture, si può controllare il flusso esecutivo in base ad una determinata condizione. In questo modo si può creare strutture di semplice selezione o di tipo iterativo (cicli). Le istruzioni assembly che vengono utilizzate per questo scopo sono principalmente di due tipo: salto e confronto.I salti possono essere incondizionati o condizionati.JMP effettua un salto incondizionato. In genere l'indirizzo di riferimento è un'etichetta.La condizione del salto è sempre dettata dai valori del registro dei flag. I flag più usati per i salti sono:Il ciclo a controllo in codaL'iterazione è una struttura che permette di ripetere più volte un'istruzione sotto il controllo di una condizione.\"in assembly, attraverso la logica dei salti, viene rappresentato così:\"esempio:Dato che il controllo della condizione viene eseguito alla fine del ciclo, le istruzioni in sequenza vengono eseguite comunque almeno una volta, anche se la condizione era già verificata in partenza. In pratica:Questo spezzone di codice dovrebbe controllore se AX = 10d, e in caso contrario incrementare AX. In caso favorevole uscire dal ciclo. Vediamo però che AX vale già 10d, tuttavia tale registro viene comunque incrementato (alla fine varrà 000Bh). Inoltre, in questo particolare programma, il ciclo non finirà mai: AX varrà 11, poi 12, poi 13 e non diventerà mai uguale a 10. Sarebbe buona norma, nelle condizioni, evitare di esprimere un'uguaglianza:\"In questo modo abbiamo risolto il problema del ciclo infinito. Tuttavia, a causa del fatto che la sequenza viene eseguita almeno una volta, in genere si evita il ciclo a controllo in coda e si utilizza invece quello a controllo in testa.Il ciclo a controllo in testaUna struttura iterativa a controllo in testa si può descrivere, ad alto livello, così:\"Equivale alla while (condizione) { sequenza } del C.in assembly:\"esempio:\"La differenza tra questa struttura e quella a controllo in coda sta nel fatto che se la condizione è inizialmente verificata, la sequenza di istruzioni non viene eseguita nemmeno una volta.Il ciclo a contatoreIl ciclo a contatore ha una struttura di questo tipo:\"Possiamo utilizzare un ciclo a contatore se vogliamo ripetere un blocco di istruzioni per un numero di volte noto a priori.i cicli in assembly sono in genere a decremento:\"Come contatore si usa di solito il registro CX (registro contatore, appunto), perché esiste un'istruzione che esegue le ultime due istruzioni automaticamente: l'istruzione LOOP: decrementa CX e, se CX = 0, salta all'etichetta specificata.Grazie all'istruzione LOOP diventa semplice scrivere un ciclo a contatore in assembly:L'input/output tramite l'INT 21h del DOS.L'assembly, specialmente nel mondo dei PC, non prevede funzioni di input/output già pronte. Il programmatore deve quindi creare le proprie routine o appoggiarsi a quelle create da terze parti. Negli ambienti DOS è sufficiente porre il codice del servizio richiesto in AX ed usare l'istruzione INT 21h per richiamare il relativo software interrupt, una delle caratteristiche più peculiari delle CPU Intel x86.Tra le funzioni più comuni per l'input/output da tastiera:Quindi, per acquisire un carattere (con eco sul video):\"E volendo poi stamparlo:\"Come si può vedere, sia le operazioni di acquisizione che di stampa fanno rifemento ai codici di carattere ASCII. Nel caso si voglia leggere in input una cifra numerica, per risalire al valore numerico basta sottrarre il valore 30h ( 48 in decimale ) al suo codice ASCII. Infatti 30h in ASCII corrisponde al carattere \"0\", 31h ( 49 in decimale ) all' \"1\" e così via..."
    def startTime = System.currentTimeMillis()
    for (int i = 0; i < 1000; i++) {
        def a = pattern.split(text)
        PairPartitionableDataset<Integer, String> pd = tc.createPairPartitionableDataset(new CollectionDataSourceIteratorProvider<String>(a.toList()))
        def results = pd.groupBy { tdc, item -> item.v2 }
                .collect()
    }
    def endTime = System.currentTimeMillis()
    tc.logManager.getLogger("TEST").info("Time: ${endTime - startTime} milliseconds")
}

/*ts.task { tc ->
    def pattern = Pattern.compile("([\\s]+)|([\\:\\.\\,\\;\"\\<\\>\\[\\]\\{\\}\\\\/'\\\\&\\#\\*\\(\\)\\=\\?\\^\\!\\|])")
    String text = "Assembly. Il linguaggio assembly, detto anche linguaggio assemblativo, è, tra i linguaggi di programmazione, quello più vicino al linguaggio macchina vero e proprio, pur essendo differente rispetto a quest'ultimo. Erroneamente viene spesso chiamato \"assembler\", anche se quest'ultimo termine identifica il programma \"assemblatore\" che converte il linguaggio assembly in linguaggio macchina.Caratteristiche generali dell'assembly.L'assembly ha lo scopo generale di consentire al programmatore di ignorare il formato binario del linguaggio macchina.Ogni codice operativo del linguaggio macchina viene sostituito, nell'assembly, da una sequenza di caratteri che lo rappresenta in forma \"mnemonica\"; per esempio, il codice operativo per la somma potrebbe essere trascritto come codice_1 e quello per il salto come codice_2.In secondo luogo, i dati e gli indirizzi di memoria manipolati dal programma possono essere scritti, in assembly, nella base numerica più consona al momento: esadecimale, binaria, decimale, ottale ma anche in forma simbolica, utilizzando stringhe di testo (identificatori).Il programma assembly risulta in questo modo relativamente più leggibile di quello in linguaggio macchina, con il quale mantiene però un totale (o quasi totale) isomorfismo.Il programma scritto in assembly non può essere eseguito direttamente dal processore; esso deve essere tradotto nella forma binaria corrispondente, usando un programma compilatore detto assembler.Non c'è un solo assembly.A causa di questa \"vicinanza\" all'hardware, non esiste un unico linguaggio assembly.Al contrario, ogni CPU o famiglia di CPU ha un suo proprio assembly, diverso dagli altri.Ad esempio, sono linguaggi assembly ben diversi quelli per i processori Intel x86, per i Motorola 68000 e per i Dec Alpha.Questo significa che conoscere un certo linguaggio assembly significa saper scrivere programmi solo su una determinata CPU o famiglia di CPU.Passare ad altre CPU però è relativamente facile, perché molti meccanismi sono analoghi o del tutto identici, quindi spesso il passaggio si limita all'apprendimento di nuovi codici mnemonici, nuove modalità di indirizzamento ed altre varie peculiarità del nuovo processore.Molto meno facile è invece portare un programma scritto in assembly su macchine con processori diversi o con architetture diverse: quasi sempre significa dover riscrivere il programma da cima a fondo, perché i linguaggi assembly dipendono completamente dalla piattaforma per cui sono stati scritti.Molti compilatori assembly supportano sistemi di macro che potrebbero essere impiegati per ovviare in parte a questo problema, ma si tratta di una soluzione poco efficace.Inoltre l'assembly non offre alcun \"controllo sui tipi\" (non esiste alcunché di vagamente simile al concetto di \"tipo\" nella programmazione \"low-level\"), ma lascia al programmatore la responsabilità di occuparsi di ogni singolo dettaglio della gestione della macchina e richiede molta disciplina e un esteso lavoro di commento per non scrivere codice che risulti assolutamente illeggibile (ad altri programmatori come anche a se stessi dopo qualche tempo).A fronte di questi svantaggi l'assembly offre un'efficienza senza pari e il controllo completo e assoluto sull'hardware: i programmi in assembly sono, in linea di principio, i più piccoli e veloci che sia possibile scrivere su una data macchina.Scrivere (buon) codice in assembly è dispendioso in termini di tempo, difficile e quindi molto costoso, soprattutto in prospettiva (future modifiche): per questo, raramente l'assembly è il solo linguaggio usato in un progetto mainstream, a meno che questo non sia di dimensioni e portata limitate.In genere si usa in combinazione con altri linguaggi: la maggior parte del codice viene scritta in un linguaggio ad alto livello, mentre le parti più critiche (per motivi di performance, precisione del timing o affidabilità) si scrivono in assembly.Tali problematiche sono riscontrabili principalmente su piattaforme come i \"personal computer\" attuali, dove la vastità quantitativa e l'enorme gamma qualitativa dell'hardware disponibile crea alle applicazioni low-level un oggettivo problema mai risolto (e presumibilmente non risolvibile) a livello di unificazione e standard.A ciò si aggiunga l'evoluzione costante verso una sempre maggiore stratificazione dei comuni sistemi operativi, caratterizzata da numerosi vincoli e virtualizzazioni delle periferiche fisiche e dei canali di comunicazione, che non rendono agevole lo sviluppo di un software che interagisca direttamente con l'hardware sottostante e ne gestisca direttamente le caratteristiche.Si possono però citare due esempi, peraltro correlati, di totale inversione di questo paradigma generale:Ecco allora che la possibilità di utilizzare un microcontroller con limitatissime risorse di memoria ROM e RAM scrivendo il firmware integralmente in assembly diventa essenziale al fine di minimizzare i costi, l'ingombro in piastra, la suscettibilità elettromagnetica, aumentando anche l'affidabilità (processori più \"datati\" hanno un incolmabile vantaggio in termini di milioni di ore di test e funzionamento sul campo, ossia la \"merce\" di gran lunga più preziosa per i sistemi embedded variamente critici) ed ottimizzando numerosi altri fattori.RISC e CISC.Il linguaggio assembly costituisce il cosiddetto ISA (Instruction Set Architecture) di un processore.I diversi ISA possono essere divisi in due grandi gruppi: i RISC (Reduced Instruction Set Computer) e i CISC (Complex Instruction Set Computer).Il primo gruppo tende ad avere operazioni semplici e veloci, con grande abbondanza di registri per memorizzare i risultati intermedi.Il secondo mette a disposizione del programmatore istruzioni più complesse, che a volte mimano quelle dei linguaggi di livello più alto (ad esempio, la copia di stringhe nei processori x86).In entrambi i casi, i migliori set di istruzioni tendono ad essere quelli cosiddetti \"ortogonali\", dove i diversi metodi di indirizzamento e i diversi registri possono essere usati indifferentemente in tutte le istruzioni.Famosi set di istruzioni ortogonali sono quelli del Motorola 68000 (CISC) e del MIPS (RISC).L'ISA dei processori Intel x86 era originariamente ben poco ortogonale, ed è andata via via migliorando.La distinzione tra \"set\" di istruzioni RISC e CISC è oggi un po' sfumata, perché la maggior parte dei processori consumer sono oggi dei CRISP, cioè un misto fra i due.Inoltre, alcuni processori traducono l'ISA originale in un set di istruzioni interno, per ragioni diverse e con modalità diverse:Struttura.La struttura di un tipico listato Assembly x86 per PC si articola, a grandi linee, nei seguenti termini:Vale la pena di ribadire che tale struttura, nella sua generalità, dipende quasi per intero dalla piattaforma e anche dall'assembler utilizzato e quindi non è in alcun modo universalizzabile. Architetture diverse, dai mainframe ai microcontroller, con relativi assemblatori e cross-assembler, impongono strutture di sorgente a volte nettamente diverse dal semplice esempio illustrato, relativo ai comuni PC. Per un controesempio banale, nelle architetture Harvard usate dalla quasi totalità dei microcontroller e da molte architetture di supercalcolo: Esempio di codice.Esempio di programma \"Hello world\" in assembly Intel x86 con sintassi Intel (sfrutta le chiamate al sistema operativo DOS). Non è compatibile con le versioni Assembly UNIX GNUQuesto invece è l'esempio del programma scritto per sintassi AT&T (per le architetture UNIX GNU)Microistruzioni.Quando si esegue un'istruzione Assembly, il processore (in base all'architettura presa in considerazione) esegue una serie di operazioni chiamate \"Microistruzioni Assembly\", cioè delle operazioni hardware che servono per configurare i registri e gli operatori della CPU in modo che possa essere eseguita quella istruzione.Tale processo si divide, nel caso delle CPU Intel x86 e di alcune altre, in 3 parti:Da qui la sigla FDE, Fetch-Decode-Execute, riportata nei testi di architettura e nei datasheet.Per fare un esempio per l'architettura dell'Intel 80x86 con un singolo BUS, in sintassi AT&T, questa istruzione:in cui si somma il contenuto del registro EAX con il contenuto del registro EBX e il risultato verrà salvato in EAX, vengono svolte queste microoperazioni:Su alcune architetture tali fasi risultano invece essere quattro (ad esempio, nei PIC Microchip, negli Intel 8051 e in numerosissimi core analoghi), da cui risulta anche l'effettivo rapporto tra velocità di clock ossia frequenza del quarzo esterno (es. 10 MHz) e numero di istruzioni effettivamente eseguite in un secondo. Per i PIC tale rapporto è pari ad 1/4, poiché ad ogni ciclo di clock il core esegue effettivamente una singola fase Fetch-Decode-Execute-Write e dunque sono necessari quattro cicli del clock esterno per completare una singola istruzione. Su architetture di microcontroller e core più arcaiche o comunque di diversa concezione, sono necessari anche più cicli di clock per ciascuna fase (ad esempio tre o quattro), da cui il diverso rapporto tra clock e MIPS, che nel caso del design 8051 originale richiede ad esempio 12 cicli di clock per ciascuna singola istruzione.Si ricordi infine che talune istruzioni, tra le quali tipicamente i salti incondizionati, richiedono su un numero notevole di piattaforme (sia RISC che CISC, concepite in varie epoche) un numero di cicli superiore alle altre, a causa delle operazioni accessorie (non parallelizzabili) richieste dall'aggiornamento del registro IP e di eventuali code di prefetch interne.C-asm.Talvolta, nella programmazione ad alto livello in ambienti come il DOS, c'è la necessità di effettuare alcune operazioni che sono molto più veloci usando delle istruzioni di linguaggi a basso livello (in Windows invece a causa delle protezioni della memoria si ricorre più frequentemente alle chiamate WINAPI, le chiamate in L/M sono usate per lo più per procedure matematiche accelerate o dai driver). Tra i linguaggi ad alto livello che permettono questo vi sono il C e il C++, in cui possono essere inserite nei propri sorgenti parti scritte in assembly e, che in fase di compilazione, verranno tradotte con un procedimento noto come assembler inline.Un esempio di codice scritto in C-asm (usando l'assembly Intel x86), che visualizza in binario un numero dato in input, è il seguente:Dato che oramai la potenza dei PC è elevatissima e che i compilatori hanno una grande quantità di ottimizzazioni, i programmatori \"normali\" hanno sempre meno la necessità di interfacciarsi a basso livello, a favore della portabilità e leggibilità del codice.Strutture di controllo in Assembly x86.Il processore esegue le istruzioni così come si presentano, una dopo l'altra. Tuttavia, attraverso particolari strutture, si può controllare il flusso esecutivo in base ad una determinata condizione. In questo modo si può creare strutture di semplice selezione o di tipo iterativo (cicli). Le istruzioni assembly che vengono utilizzate per questo scopo sono principalmente di due tipo: salto e confronto.I salti possono essere incondizionati o condizionati.JMP effettua un salto incondizionato. In genere l'indirizzo di riferimento è un'etichetta.La condizione del salto è sempre dettata dai valori del registro dei flag. I flag più usati per i salti sono:Il ciclo a controllo in codaL'iterazione è una struttura che permette di ripetere più volte un'istruzione sotto il controllo di una condizione.\"in assembly, attraverso la logica dei salti, viene rappresentato così:\"esempio:Dato che il controllo della condizione viene eseguito alla fine del ciclo, le istruzioni in sequenza vengono eseguite comunque almeno una volta, anche se la condizione era già verificata in partenza. In pratica:Questo spezzone di codice dovrebbe controllore se AX = 10d, e in caso contrario incrementare AX. In caso favorevole uscire dal ciclo. Vediamo però che AX vale già 10d, tuttavia tale registro viene comunque incrementato (alla fine varrà 000Bh). Inoltre, in questo particolare programma, il ciclo non finirà mai: AX varrà 11, poi 12, poi 13 e non diventerà mai uguale a 10. Sarebbe buona norma, nelle condizioni, evitare di esprimere un'uguaglianza:\"In questo modo abbiamo risolto il problema del ciclo infinito. Tuttavia, a causa del fatto che la sequenza viene eseguita almeno una volta, in genere si evita il ciclo a controllo in coda e si utilizza invece quello a controllo in testa.Il ciclo a controllo in testaUna struttura iterativa a controllo in testa si può descrivere, ad alto livello, così:\"Equivale alla while (condizione) { sequenza } del C.in assembly:\"esempio:\"La differenza tra questa struttura e quella a controllo in coda sta nel fatto che se la condizione è inizialmente verificata, la sequenza di istruzioni non viene eseguita nemmeno una volta.Il ciclo a contatoreIl ciclo a contatore ha una struttura di questo tipo:\"Possiamo utilizzare un ciclo a contatore se vogliamo ripetere un blocco di istruzioni per un numero di volte noto a priori.i cicli in assembly sono in genere a decremento:\"Come contatore si usa di solito il registro CX (registro contatore, appunto), perché esiste un'istruzione che esegue le ultime due istruzioni automaticamente: l'istruzione LOOP: decrementa CX e, se CX = 0, salta all'etichetta specificata.Grazie all'istruzione LOOP diventa semplice scrivere un ciclo a contatore in assembly:L'input/output tramite l'INT 21h del DOS.L'assembly, specialmente nel mondo dei PC, non prevede funzioni di input/output già pronte. Il programmatore deve quindi creare le proprie routine o appoggiarsi a quelle create da terze parti. Negli ambienti DOS è sufficiente porre il codice del servizio richiesto in AX ed usare l'istruzione INT 21h per richiamare il relativo software interrupt, una delle caratteristiche più peculiari delle CPU Intel x86.Tra le funzioni più comuni per l'input/output da tastiera:Quindi, per acquisire un carattere (con eco sul video):\"E volendo poi stamparlo:\"Come si può vedere, sia le operazioni di acquisizione che di stampa fanno rifemento ai codici di carattere ASCII. Nel caso si voglia leggere in input una cifra numerica, per risalire al valore numerico basta sottrarre il valore 30h ( 48 in decimale ) al suo codice ASCII. Infatti 30h in ASCII corrisponde al carattere \"0\", 31h ( 49 in decimale ) all' \"1\" e così via..."
    def dataParallelismPool = new jsr166y.ForkJoinPool(10)
    GParsPool.withExistingPool(dataParallelismPool) {
        def startTime = System.currentTimeMillis()
        for (int i = 0; i < 1000; i++) {
            def a = pattern.split(text)
            def results = a.parallel.filter{item->item.length() > 5}.collection
        }
        def endTime = System.currentTimeMillis()
        tc.logManager.getLogger("TEST").info("Time: ${endTime-startTime} milliseconds")
    }
}*/

runtime.run(ts)
